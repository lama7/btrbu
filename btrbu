#!/usr/bin/env lua

-- system requires
local io = require("io")
local math = require("math")
local os = require("os")
local table = table -- for faster access

-- local requires
local MAX_INFO = 3

local usage = {
[[
Usage:  btrbu [OPTIONS] [archive1=/path/to/subvolume1] [archive2=/path/to/subvolume2] ...
]],
[[
btrbu is a program to create and manage snapshots and backups for btrfs subvolumes.  Minimally, it requires a snapshot destination path, a backup destination path, and a list of source volumes to take snapshots of and backup. These can all be supplied on the command line or in a config file.  Names for the snapshots and backups must be supplied- btrbu will append a timestamp to the name to create the snapshot/backup. 
]],
[[
If no archive/subvolume pairs are specified on the command line, btrbu will look for them in a config file.  The default config file is "~/.config/btrbu-conf" but the user can specify a particular file with the "--config" option.  If there are no archive/subvolume pairs specified in a config file, then there is nothing to do and the user gets this message.  Command line archive/subvolume pairs take precedence and prevent operations on archive/subvolume pairs specified in a config file.  NO ATTEMPT IS MADE TO RECONCILE BETWEEN THE COMMAND LINE AND CONFIG FILE FOR ARCHIVE/SUBVOLUME PAIRS, BEHAVIOR IS EITHER/OR.
]],
[[
All command line options can also be specified in a config file.  In the case where an option is defined both on the command line and in the config file, btrbu defaults to using the command line.
]],
[[
Options:
]],
}
local usage_length = #usage

-- table of valid options 
-- * table key is the option 
-- * value is another table with 
--   * "help_text" as one key and 
--   * "args" representing how many arguments the option takes.  
-- For now, only 1 or 0 arguments per option is supported
local btrbu_opts = {
    snapshot_dir = {
                     help_text = [[
Path to destination for snapshots
]],
                     args = 1,
    },
    backup_dir = {
                     help_text = [[
Path to location for backups.  For now, it is assumed that the destination is a btrfs based filesystem.
]],
    },
    config = {
                     help_text = [[
Path to a configuration file.  The configuration file contains a lua table with the desired option settings and archive/subvolume pairs.  See below for details and an example.
]],
                     args = 1,
    },
    snaps_only = {
                     help_text = [[
If specified only snapshots will be taken, no backups will be used.
]],
                     args = 0,
    },
    keep_daily = {
                     help_text = [[
Number of daily backups to be kept. Dailies kept have 24 hours between them.
]],
                     args = 1,
    },
    keep_weekly = {
                     help_text = [[
Number of weeklys backups to be kept. Weeklies kept have (7*24) hours between them.
]],
                     args = 1,
    },
    keep_monthly = {
                     help_text = [[
Number of monthly backups to be kept.  Monthlies kept have (4*7*24) hours between them.
]],
                     args = 1,
    },
    help = {
                     help_text = [[
Display this useful information.  The help option prevents execution of any operations, why would you be specifiying help, otherwise?
]],
                     args = 0,
    },
    verbose = {
                     help_text = [[
Option to turn on output about what is happening.  The default is no output, so if this is present the firehose is on.
]],
                     args = 1,
    },
    prune = {
                     help_text = [[
*** THIS REMOVES SNAPSHOTS AND BACKUPS- BE SURE THE RESULT IS KNOWN BY USING THE `dryrun` OPTION WITH THE DESIRED KEEP POLICY.  YOU HAVE BEEN WARNED. *** Applies keep policy without taking any snapshots or performing backups for the current run.  Can be used blank or a timestamp can be assigned.  The timestamp must be of the form `YYYYMMDDhhmm`.  If a timestamp is supplied then it applies the keep policy with the supplied timestamp used as the MOST RECENT entry.  Otherwise, a current timestamp is used.  When used with `dryrun`, useful for seeing the results of a keep policy on a large corpus of snapshots and backups.  Use of this option prevents any other actions, such as taking snapshots or performing backups, from occurring.
]],
                     args = "?",
    },
    dryrun = {
                     help_text = [[
No actual operations are performed.  Verbosity is set to max so the user can see what actions would be performed.  Because of how btrbu is implemented, the dryrun assumes all btrfs level actions will complete without error.
]],
                     args = 0,
    },
    sudo = {
                     help_text = [[
This option will cause the individual btrfs commands to be prepended with "sudo -n."  For this to work the user must have the appropriate permissions setup in the /etc/suoders file.  Useful for running btrbu as a normal user.  This option only affects the btrfs commands, not any hooks that might be configured.
]],
                     args = 0,
    },
}

local btrbu_optcnt = 0
for k,_ in pairs(btrbu_opts) do btrbu_optcnt = btrbu_optcnt + 1 end

local configfilehelp = {
    [[
CONFIGURATION FILES
    ]],
    [[
At some point, if backing up several different subvolumes for instance, a configuration file might become desirable to make the command line more manageable.  btrbu will look for a configuration file in `~/.config/btrbu-conf` if no file is specified on the command line.  Alternatively:
    ]],
    [[
    btrbu --config=/path/to/myconfig
    ]],
    [[
Configuration files take advantage of lua's table syntax.  Don't worry, it's extremely easy to use.  A configuration file looks simply like so:
    ]],
    [[
    return { 
        subvolumes =  {
            archive1="/path/to/subvolume1",
            archive2="/path/to/subvolume2",
            archive3="/path/to/subvolume3",
        },
        -- the leading double-dash means a comment to lua, so that can be taken
        -- advantage of as well
        snapshot_dir = "/pool/snapshots",
        backup_dir = "/backup",
    }
    ]],
    [[
If an option can be specified on the command line, it can also be specified in the configuration file.  Be sure to susbstitute a `'_'` for any `'-'` characters in the command line option.  So the `--snapshot-dir` option would be specified as `snapshot_dir` in a configuration file.
    ]],
    [[
Configuration files and command line options can be mixed and matched as well.  The rule is that the command line overrides any configuration file settings.  For archive name/ subvolume pairs, anything specified on the command line overrides ALL of the subvolumes in the configuration file.  So if there are 5 subvolumes specified in the configuration file, but a single achive/subvolume is specified on the command line, only the command line archive/subvolume is dealt with.  Basically, btrbu assumes the user knows what they are doing and tries not to get in the way.
    ]]
}

local runtime = {}
runtime.subvolumes = {}
local options = {}

-- do some rudimentary command line parsing
--[[
    Options are denoted by a '--' prefix and are of the form "--option" or "--option=value"
    Archive/subvolume pairs are of the form "archive=subvolume"
    We try to remove remove white space if it is used when the command is invoked
    Also, order must be options followed by archive/subvolume pairs
--]]
local i = 1
local o = 1
while i <= #arg do
    local m = arg[i]:match("^%-%-(.+)")
    -- is this the start of an option argument? (leading '--')
    if o and m then
        options[o] = m
        i = i + 1
        if not arg[i] then break end;
        -- check if there's a trailing '='
        if m:match(".+=$") then
            -- yes, so grab next argument, stuff it and loop
            if not arg[i] then
                print("Argument parsing error at: "..options[o])
            end
            options[o] = options[o]..arg[i]
            i = i + 1
            o = o + 1
        -- does current match have a '='?
        elseif not m:find("=") then
            -- 2 possibilities- next arg could have the '=' or it can be 
            -- a new option
            -- chk for leading '='...
            if arg[i]:find("^=.*") then
                -- next arg has a leading '=', so it's either alone or already
                -- part of the value string
                if arg[i] == '=' then 
                    -- alone, so stuff it and then grab the next argument
                    options[o] = options[o]..'='
                    i = i + 1
                    -- make sure there is a next argument...
                    if not arg[i] then 
                        print("Argument parsing error at: "..options[o])
                        return
                    end
                end
                options[o] = options[o]..arg[i]
                i = i + 1
                o = o + 1
            -- chk for leading '--'...
            elseif arg[i]:find("^%-%-.*") then
                o = o + 1
            else
                -- next arg doesn't have '=' and isn't another option, so it
                -- must be the first archive/subvolume pair
                o = nil
            end
        else
            -- option match had an '=' in it, so stuff it and on to the next
            -- option
            o = o + 1
        end -- elseif not m:find...
    else
        -- not a leading '--' so we're looking for "archive=subvolume"
        -- variants, also- no more options allowed after this
        if m then
            print("Argument error- "..m)
            print("ALL options must precede archive/subvolume pairs.")
            return
        end
        
        if arg[i]:find("=") then
            m,v = arg[i]:match("^(.+)=(.+)$")
            if m then
                runtime.subvolumes[m] = v
                i = i + 1
            else
                m = arg[i]:match("^(.+)=$") 
                if m then
                    i = i + 1
                    if not arg[i] then
                        print("No subvolume specified for archive: "..m)
                        return
                    end
                    runtime.subvolumes[m] = arg[i]
                    i = i + 1
                else
                    print("No archive specified for subvolume: "..arg[i])
                    return
                end
            end
        else
            -- no '=' here, assume this is the archive name
            local archive = arg[i]
            i = i + 1
            if not arg[i] then
                print("No subvolume specified for archive: "..archive)
                return
            end

            -- now find the rest of the archive/subvolume pair
            if not arg[i]:find("=") then
                print("No subvolume specified for archive: "..archive)
                return
            end
            if arg[i] == "=" then
                -- just an '=' sign, so grab the next argument
                i = i + 1
                if not arg[i] then
                    print("No subvolume specified for archive: "..archive)
                    return
                end
                runtime.subvolumes[archive] = arg[i]
                i = i + 1
            else
                m = arg[i]:match("^=(.+)")
                if m then
                    runtime.subvolumes[archive] = m
                    i = i + 1
                else
                    print("Argument error: "..arg[i])
                    return
                end
            end    
        end
    end -- if o and m...
end -- while...

-- now setup runtime options
-- start with the options from the command line
if #options ~= 0 then
    for _,opt in ipairs(options) do
        -- must parse out option and value....
        if not opt:find("=") then
            -- just a switch
            local o = opt:gsub("-","_")
            if not btrbu_opts[o] then
                print("Invalid Option: "..opt)
                return
            elseif btrbu_opts[o].args ~= 0 and btrbu_opts[o].args ~= "?" then
                print("Option "..opt.." expects a value, none given.")
                return
            else
                runtime[o] = 1
            end
        else
            local k,v = opt:match("^([%w%-_]+)=(.+)$") 
            if not k then 
                print("Invalid Option: "..opt) 
                return
            end
            k = k:gsub("-","_")
            if not btrbu_opts[k] then
                print("Invalid Option: "..opt)
            elseif btrbu_opts[k].args == 0 then
                print("No value should be assigned to option: "..k:gsub("_","-"))
                return
            else
                if v == "DEBUG" then
                    if k ~= "verbose" then 
                        print("Invalid value '"..v.."' for option --"..k)
                        return
                    else
                        runtime.verbose = MAX_INFO
                    end
                else
                    local numbers_only = { keep_daily = 1, 
                                           keep_weekly = 1,
                                           keep_monthly = 1, }
                    if numbers_only[k] then
                        local chk = tonumber(v)
                        if not chk then
                            print("Invalid value "..v.." for option "..k..": should be a number.")
                            return
                        end
                        v = chk
                    end
                    runtime[k] = v
                end
            end
        end
    end
end

 --[[ for debug...
print("User specified options:")
for _,v in ipairs(options) do print(v) end
print("Internal runtime options:")
for k,v in pairs(runtime) do
    print(k,v)
end
print("subvolumes:")
for k,v in pairs(runtime.subvolumes) do
    print(k,v)
end
 --]]

-- to keep this straight forward... if user specifies a config file
-- use that, if not, look for "~/.config/btrbu-conf
local cf = ""
if runtime.config then 
    local m = runtime.config:match("^~(.+)$")
    if m then
        cf = os.getenv("HOME")..m
    else
        cf = runtime.config
    end
else
    cf = os.getenv("HOME").."/.config/btrbu-conf"
end
-- try to load the config file
local settings, err = loadfile(cf)
-- now setup runtime config
-- if there is a conflict between command line and config file, use command line
-- if "archive=subvolume" specified on command line, only work with those 
-- supplied on command line.  DO NOT TRY TO RECONCILE COMMAND LINE WITH CONFIG
-- FILE FOR THIS.  IT'S ONE OR THE OTHER.
if settings then
    local cf_settings = settings()
    -- setup the subvolumes- subvolumes defined on command line override those
    -- in the config file; otherwise, add the entry
    if next(runtime.subvolumes) == nil then
        -- if table is empty, no command line settings for subvolumes, so just
        -- grab the whole table from config file
        runtime.subvolumes = cf_settings.subvolumes
    end
 
    -- setup snaphooks and backuphooks if present.  Note that these are available ONLY from a config
    -- file.
    runtime.snaphooks = cf_settings.snaphooks
    runtime.backuphooks = cf_settings.backuphooks

    -- go through and setup config file settings- if the option was already 
    -- setup on the command line, leave it
    if not runtime.snapshot_dir then
        runtime.snapshot_dir = cf_settings.snapshot_dir
    end
    if not runtime.backup_dir then
        runtime.backup_dir = cf_settings.backup_dir
    end

    if not runtime.keep_daily then
        runtime.keep_daily = cf_settings.keep_daily or 1
    end
    if not runtime.keep_weekly then 
        runtime.keep_weekly = cf_settings.keep_weekly or 0
    end
    if not runtime.keep_monthly then
        runtime.keep_monthly = cf_settings.keep_monthly or 0
    end
    if not runtime.snaps_only then
        runtime.snaps_only = cf_settings.snaps_only
    end
    if not runtime.verbose then
        runtime.verbose = tonumber(cf_settings.verbose) or 0
    else
        runtime.verbose = tonumber(runtime.verbose)
    end
    if not runtime.dryrun then
        runtime.dryrun = cf_settings.dryrun or nil
    end 
    if not runtime.sudo then
        runtime.sudo = cf_settings.sudo or nil
    end
end

-- if we're doing a dryrun, set verbose to max 
if runtime.dryrun then runtime.verbose = MAX_INFO end

-- Sanity check- command line options and config file, if it exists, have been
-- processed.  In order to try to do anything, we need a snapshot destination,
-- and backup destination and some subvolumes to snapshot/backup.
-- ... OR ...
-- If the "--snaps_only" option is set then we need a snapshot destination and a
-- list of subvolumes to snapshot.
-- Also, the "--help" option is an override of sorts.  If that option was listed
-- on the command line, we display the usage text and exit.  Don't perform any
-- actions, even if we have enough to do so.
if ( not runtime.snapshot_dir or not runtime.backup_dir or next(runtime.subvolumes) == nil) or 
   ( runtime.snaps_only and 
     ( not runtime.snapshot_dir or next(runtime.subvolumes) == nil ) ) or runtime.help then
       -- DISPLAY USAGE TEXT AND EXIT
       -- we need to create a sorted table first...
       local sorted_opts = {}
       for k,_ in pairs(btrbu_opts) do table.insert(sorted_opts, k) end
       table.sort(sorted_opts)
       -- build the option text here prior to printing usage info
       for _, k in ipairs(sorted_opts) do
           local s = "  --"..k:gsub("_","-") -- map the '_' character to a
                                             -- '-' for the user to see and use
                                             -- when actually using the command
                                             -- line.  Internally, all '-' are
                                             -- mapped to '_' characters so the 
                                             -- tables work, since a '-' is not
                                             -- valid character for variables
                                             -- etc.
           table.insert(usage, s..string.rep(" ", 18-s:len())..btrbu_opts[k].help_text)
       end
       for _,v in ipairs(configfilehelp) do table.insert(usage, v) end
       -- get current terminal width
       local fd = io.popen("tput cols")
       local cols = fd:read("*a")
       fd:close()
       cols = tonumber(cols) - 1
       -- now go through the individual entries and fix them to the terminal width
       for i,v in ipairs(usage) do 
           local fixed_text = ""
           -- check for the 1 text block we don't want to reformat
           if not usage[i]:match("%sreturn %{") then 
               -- remove all linefeeds
               fixed_text = usage[i]:gsub("[\r\n]", " ")
               -- now format to the terminal width
               local length = fixed_text:len()
               if length > cols then
                   -- insert linefeeds as needed
                   local j = 1
                   local s = ""
                   repeat
                       local adjusted = cols
                       if (i > usage_length and i < (usage_length + btrbu_optcnt)) and s ~= "" then 
                           adjusted = adjusted - 18 
                       end
                       while fixed_text:sub(j+adjusted, j+adjusted) ~= " " do
                           adjusted = adjusted - 1
                       end
                       if j+adjusted+1 >= length then
                           s = s..fixed_text:sub(j, j+adjusted)
                       else
                           s = s..fixed_text:sub(j, j+adjusted).."\n"
                       end
                       if i > usage_length and i <= (usage_length + btrbu_optcnt) then 
                           s = s..string.rep(" ",18) 
                       end
                       j = j+adjusted+1
                   until j >= length
                   fixed_text = s
               end
               if i < usage_length or i >= (usage_length + btrbu_optcnt) then 
                   fixed_text = fixed_text.."\n" 
               end
           else -- if not usage(...
               fixed_text = usage[i]
           end
           print(fixed_text)
       end
   return -- exit program
end

-- ########################################
-- btrfs command functions

local function info(level, text)
    if runtime.verbose ~= 0 and runtime.verbose >= level then
        print(text)
    end
end

--[[

--]]
local btrbu_error = ""
local function doit(cmd)
    if runtime.sudo then
        cmd = cmd:gsub("btrfs", "sudo -n btrfs")
    end
    info(2,cmd)
    local rs
    if not runtime.dryrun then
        fd = io.popen(cmd)
        rs = fd:read("*a")
        fd:close()
    else
        rs = "DRYRUN- no action performed"
    end
    info(3,rs)
    -- look for any btrfs errors first
    btrbu_error = rs:match("ERROR:%s*(.*)")
    if not btrbu_error then
        -- now check if sudo was setup properly...
        btrbu_error = rs:match("sudo: a password is required")
    end
    if btrbu_error then
        return false
    else
        return rs
    end
end

--[[

--]]
local function btrfs_sv_delete(sv)
    return doit("btrfs subvolume delete -c "..sv.." 2>&1")
end

--[[

--]]
local function btrfs_sv_snapshot(s,d)
    return doit("btrfs subvolume snapshot -r "..s.." "..d.." 2>&1")
end

--[[
    Ex:
    btrfs send -p cnkl77.2005052042/ cnkl77.2005152143/ | btrfs receive /backup/
--]]
local function btrfs_send(p,s,d)
    if not p then
        return doit("{ btrfs send "..s.." | btrfs receive "..d.." ; } 2>&1")
    else
        return doit("{ btrfs send -p "..p.." "..s.." | btrfs receive "..d.." ; } 2>&1")
    end
end

-- ########################################
--

local function tstoTime(ts)
    local t = {}
    t.year = ts:sub(1,4)
    t.month = ts:sub(5,6)
    t.day = ts:sub(7,8)
    t.hour = ts:sub(9,10)
    t.min = ts:sub(11,12)
    t.sec = 0
    return os.time(t)
end

--[[
    Builds a table of archive names along with all the timestamps associated with those archives
    Typically, this will be either a snapshot directory or a backup directory
--]]
local function buildTbl(path, current_ts)
    local fd = io.popen("find "..path.." -maxdepth 1 -print")
    local blob = fd:read("*a")
    fd:close()
    local t = {}
    for s in blob:gmatch("[^\r\n]+") do
        local name, ts = s:match(".*/(%g+)%.(%d%d%d%d%d%d%d%d%d%d%d%d)$")
        if name then
            if not t[name] then
                t[name] = {}
            end
            if ts <= current_ts then table.insert(t[name], ts) end
        end
    end
    -- if doing a dryrun, then find won't return anything with the latest timestamp,
    -- so we need to insert it here as a "pretend" file for the code to work with
    -- exception is if we're pruning, in which case we don't force the inserton of the "pretend" file
    -- since prune is run by itself- other options/actions are not performed
    -- make sure the table timestamp tables are sorted
    for name, _ in pairs(t) do 
        if runtime.dryrun and not runtime.prune then table.insert(t[name], current_ts) end
        table.sort(t[name]) 
    end

    return t
end

--[[
    Returns the most recent timestamp that is common to both the snaps and 
    backups.  Note that backups will NOT have the current timestamp in it since we haven't
    tried to do a backup yet.  Btrfs needs a common archive to work with when generating incremental
    backups.
--]]
local function getParentfromKeeps(snapkeept, backupkeept, current_ts)
    local max = nil
    for k, _ in pairs(snapkeept) do
        -- if this snapshot timestamp is in the backup list, it's a candidate, otherwise move on
        if backupkeept[k] then
            if not max and k ~= current_ts then max = k
            elseif k < current_ts then max = tostring(math.max(max, k))
            end
        end
    end

    return max
end

--[[
    Returns identical value to above function, except it takes 2 lists instead of tables.  It just 
    massages the list into a table and then calls the above function for processing
--]]
local function getParentfromCurrent(snaplist, backuplist, current_ts)
    local function toTbl(list)
        local t = {}
        for _,v in ipairs(list) do t[v] = 1 end
        return t
    end

    -- just taking advantage of common processing, we just massaged things to work with this function
    return getParentfromKeeps(toTbl(snaplist), toTbl(backuplist), current_ts)
end

--[[
    Function to determine what timestamps to keep.  This was a mess to figure
    out.  Only managed it because I built the algorithm for 1 case and then
    worked backwards to generalize it to work for 3 different intervals- daily,
    weekly and monthly

    Params:  tlist- table of timestamps to work through
             keep_tbl- destination table for timestamps to keep
             max_keeps- maximum number of keeps
             ts_start- seed timestamp when determining the slice
                       of timestamps from the tlist
             interval- a function that takes a timestamp as its first
                       parameter and a interval count for the second
--]]
local function getKeeps(timestamps, keep_tbl, max_keeps, ts_start, interval)
    -- scan backwards until through the list to find the starting timestamp
    local i = #timestamps
    while i ~= 0 and timestamps[i] > ts_start  do
       i = i - 1
    end
    if i == 0 then return nil end
    
    -- now start pulling timestamps
    local keep_cnt = 0
    local oldest_keep = nil
    repeat
        -- at this point, i is index to the most recent timestamp for the
        -- current interval so record it
        keep_tbl[timestamps[i]] = 1
        -- setup return value
        oldest_keep = timestamps[i]
        keep_cnt = keep_cnt + 1
        if keep_cnt == max_keeps then return oldest_keep end
        -- get next most recent timestamp for the current interval (days,weeks,
        -- months)
        local tsref = interval(timestamps[i], 1)
        i = i - 1
        -- this loop skips timestamps between the recorded one (in oldest_keep) 
        -- and the next next valid timestamp returned by the interval function
        while ( i ~= 0 and timestamps[i] > tsref ) do
            i = i - 1
        end
    until i == 0

    return oldest_keep
end

local function bldKeepList(ts_list)
    -- these are some support functions that only bldKeepList uses...
    --################################################################################
    -- returns a formatted timestamp for days_cnt days ago.
    -- The timestamp is set to the final minute of that day
    local function prevDay(ts, days_cnt)
        local t = os.date("*t", tstoTime(ts) - (days_cnt*24*3600))
        return string.format("%u%02u%02u%02u%02u",
                             t.year,
                             t.month,
                             t.day,
                             23,
                             59)
    end

    -- returns the most recent day of the previous week, initially, this is 
    -- always Saturday, but we can make that configurable...
    -- Sunday is day 1...Saturday is 7
    local function prevWeek(ts, week_cnt)
        local t = os.date("*t", tstoTime(ts))
        if t.wday ~= 7 then
            t = os.date("*t", os.time(t) - (24*3600)*(t.wday))
        end
        t = os.date("*t", os.time(t) - (week_cnt*(7*24*3600)))
        return string.format("%u%02u%02u%02u%02u",
                             t.year,
                             t.month,
                             t.day,
                             23,
                             59)
    end

    -- return last day of month that is months_cnt back
    -- it mimics the functionality of the prevWeek function, but works on months
    local function prevMonth(ts, months_cnt)
        local t = os.date("*t",tstoTime(ts))
        local chk_lastday = os.date("*t",os.time({ year = t.year,
                                                   month = t.month + 1,
                                                   day = 0 }))
        -- if months_cnt == 0 and the entry timestamp is the final day of the 
        -- month, nothing to do.  If entry timestamp is not the final day, return
        -- the final day of the previous month.  If months_cnt ~= 0 the return
        -- the final day of the month for months_cnt back.  For reference, using the
        -- lua libraries, month = month + 1 and day = 0 will return the last day of
        -- month
        if months_cnt ~= 0 then
            t = os.date("*t", os.time( { year = t.year,
                                         month = t.month-months_cnt+1,
                                         day = 0,
                                         hour = 23,
                                         min = 59 }
                                       )
                    )
        elseif t.day ~= chk_lastday.day then
            t = os.date("*t", os.time( { year = t.year,
                                         month = t.month,
                                         day = 0,
                                         hour = 23,
                                         min = 59 }
                                       )
                    )
        end

        return string.format("%u%02u%02u%02u%02u",
                             t.year,
                             t.month,
                             t.day,
                             t.hour,
                             t.min)
    end

    --################################################################################
    -- start of bldKeepList code...
    local keeps = {}
    local oldest_keep = nil
    -- check for case of 0 keeps specified.  In this instance, we should always return the latest 
    -- timestamp as the only keep
    if runtime.keep_daily + runtime.keep_weekly + runtime.keep_monthly == 0 then
        -- if this is a manual prune (prune options specified on command line, then nothing to do
        if runtime.prune then 
            return nil
        else
            -- not a manual prune, keep the latest timestamp
            keeps[ts_list[#ts_list]] = 1
            return keeps
        end
    end

    -- at least 1 keep is specified, so keep the most current timestamp
    keeps[ts_list[#ts_list]] = 1
    -- at this point, we have some number of keeps specified and the most recent timestamp has already
    -- been added to the keep list.  This timestamp counts against the shortest interval that keeps are
    -- specified for.  At this point, we could be pruning because of the command line OR this could be
    -- the prune after snapshots/backups have been completed.
    -- 1st, check the case where only 1 keep is specified at any time interval. In that case. we're 
    -- already done since we've already kept the most recent timestamp
    if runtime.keep_daily + runtime.keep_weekly + runtime.keep_monthly == 1 then
        return keeps
    end
    -- more than 1 keep specified, so start at the daily interval and work our way out... 
    -- REMEMBER: WE ALREADY HAVE THE MOST RECENT TIMESTAMP AS A KEEP AT THIS POINT
    if runtime.keep_daily ~= 0 then
        if runtime.keep_daily == 1 then
            -- already have the daily keep, so setup oldest_keep and continue
            oldest_keep = ts_list[#ts_list]
        else
            oldest_keep = getKeeps(ts_list,
                                   keeps,
                                   runtime.keep_daily-1, -- -1 for the current timestamp
                                   prevDay(ts_list[#ts_list], 1),
                                   prevDay
                                  )
        end
    end
    if runtime.keep_weekly ~= 0 then
        local wkeepn = runtime.keep_weekly
        -- if daily keeps is 0, then the current timestamp counts against the weekly keeps
        -- otherwise, proceed as normal
        if runtime.keep_daily == 0 then wkeepn = wkeepn - 1 end
        if wkeepn == 0 then
            -- means we keep 1 weekly and the current timestamp is that keep, so setup
            -- oldest keep and continue
            oldest_keep = ts_list[#ts_list]
        else
            oldest_keep = getKeeps(ts_list,
                                   keeps,
                                   wkeepn,
                                   prevWeek(prevDay(oldest_keep or ts_list[#ts_list], 1), 0),
                                   prevWeek
                                  )
        end
    end
    if runtime.keep_monthly ~= 0 then
        local mkeepn = runtime.keep_monthly
        -- if there were no daily or weekly keeps, then the current timestamp counts against
        -- the monthly keep
        if runtime.keep_daily + runtime.keep_weekly == 0 then mkeepn = mkeepn - 1 end
        if mkeepn ~= 0 then
            getKeeps(ts_list,
                     keeps,
                     mkeepn,
                     prevMonth(prevDay(oldest_keep or ts_list[#ts_list], 1), 0),
                     prevMonth
                    )
        end
    end

    return keeps
end

--[[
    function to display keep information
--]]
local function showKeeps(name, snapkeeps, backupkeeps, ts)
    info(1, "----------------------------------------")
    info(1, "Archive: "..name)
    info(1, "Timestamp: "..ts)
    info(1, "Keep Policy:")
    info(1, "\t"..runtime.keep_daily.." daily\n\t"..runtime.keep_weekly.." weekly\n\t"..runtime.keep_monthly.." monthly")
    -- show what we're keeping
    -- only do this if verbose is sufficiently high, otherwise just wasting time
    if runtime.verbose >= 1 then
        local function displayKeeps(whichkeep,keeplist,path,suffix)
            info(1, whichkeep)
            for k,_ in pairs(keeplist) do
                info(1,"\t"..path.."/"..suffix.."."..k)
            end
        end
        displayKeeps("Keeping snapshots:", snapkeeps, runtime.snapshot_dir, name)
        if backupkeeps then
            displayKeeps("Keeping backups:", backupkeeps, runtime.backup_dir, name)
        end
    end
end

--[[
    Little helper function to consolidate some common processing
--]]
local function applyKeepPolicy(list, keeps, name, path)
    info(2, "Removing Subvolumes")
    for _,v in ipairs(list) do
        if not keeps[v] then
            assert(btrfs_sv_delete(path.."/"..name.."."..v), btrbu_error)
        end
    end
end
 
--[[
    fixup the snapshot_dir, backup_dir values and subvolume directories- convert
    leading '~' and '.' to the appropriate value so we have a full path specfication
--]]
local function pathFixup(path)
    local m = path:match("^~(.*)$") 
    if m then
        return os.getenv("HOME")..m
    end
    m = path:match("^%.(.*)$") 
    if m then
        return os.getenv("PWD")..m
    end
    -- nothing to do
    return path
end

--[[
    this function is used as a coroutine for the hooks functionality.
    in order to not block the rest of the program if the hook happens to be a long running program,
    like backing up snapshots to a remote repository, we append a "touch" shell command that will
    create a temporary file we can wait on.  Once that file appears, we know that the main hook has
    completed and we can safely continue.
--]]
local function hook ( cmd, inst )
    -- generate a random number for the semaphore file name...
    local semfile = "/tmp/semfile"..math.random(os.time()+os.clock()*1000000)
    local f = io.open(semfile)
    -- do our best to get a unique name for our semaphore file, if other instances of btrbu are
    -- started within a second(like from different cron configs), this might not be enough...
    -- depends on how we do with the seeding we use
    while f do
        f:close()
        semfile = "/tmp/semfile"..math.random(os.time()+os.clock()*1000000)
        f = io.open(semfile)
    end

    if not runtime.dryrun then
        info(1, "Starting hook:  "..cmd)
        cmd = cmd.." ; touch "..semfile
        local f = io.popen(cmd)
        while 1 do
            local sem = io.open(semfile)
            if not sem then
                coroutine.yield(0)
            else
                sem:close() -- semaphore file...
                os.remove(semfile)
                f:close() -- popen pipe ...
                break
            end
        end
    else
        -- to at least let the coroutine do it's thing once, we'll just yield and then exit rather
        -- than looping.  Alternatively, we could loop a set number of times so the coroutine stuff
        -- can get exercised... 
        info(MAX_INFO, "Semfile: "..semfile)
        info(MAX_INFO, "DRYRUN- hook to execute: "..cmd)
        coroutine.yield(0)
    end
    return inst
end

--[[
    an event handler of sorts for the hooks that might be running
--]]
local colist = {} -- table of coroutines- populated by the hook setup code for snaphooks or backuphooks
local function handleHooks()
    if #colist == 0 then
        info(1, "No hooks running.")
        return
    end

    info(1, "Waiting for hooks to complete...")
    repeat
        for i, codata in ipairs(colist) do
            local status, r = coroutine.resume(codata.co)
            if r~= 0 then
                if not runtime.dryrun then
                    info(1,"Hook Completed: "..codata.cmd)
                else
                    info(3,"DRYRUN Completed: "..codata.cmd)
                end
                table.remove(colist, i)
            end
        end
    until #colist == 0
end

-- =============================================================================================
-- this is where script execution actually starts.  Everything to this point has been prep work or 
-- setup.  Now, we'll actually start working with the system to take snapshots 
runtime.snapshot_dir = pathFixup(runtime.snapshot_dir)
runtime.backup_dir = pathFixup(runtime.backup_dir)
for name, path in pairs(runtime.subvolumes) do
   runtime.subvolumes[name] = pathFixup(path)
end

-- assemble a timestamp to use as a suffix
local t = os.date("*t")
local timestamp = string.format("%u%02u%02u%02u%02u", 
                                t.year, 
                                t.month, 
                                t.day, 
                                t.hour, 
                                t.min)

-- if prune option is selected, perform it and exit
if runtime.prune then
    if runtime.prune ~= 1 then
        if runtime.prune:match("^%d%d%d%d%d%d%d%d%d%d%d%d$") then
            timestamp = runtime.prune
        else
            print("Invalid timestamp format for prune")
            print("Prune argument should be assigned a timestamp formatted as 'YYYYMMDDhhmm'")
            print("Aborting")
            return
        end
    end

    local snaps = buildTbl(runtime.snapshot_dir, timestamp)
    local backups = buildTbl(runtime.backup_dir, timestamp)

    for name, _ in pairs(runtime.subvolumes) do
        local snapkeeps = bldKeepList(snaps[name])
        local backupkeeps = bldKeepList(backups[name])
        if not snapkeeps and not backupkeeps then 
            print("No keeps specified, nothing to do.")
            return
        end
        showKeeps(name, snapkeeps, backupkeeps, timestamp)

        -- apply keep policy to snapshots
        applyKeepPolicy(snaps[name], snapkeeps, name, runtime.snapshot_dir)
        applyKeepPolicy(backups[name], backupkeeps, name, runtime.backup_dir)

        info(1, "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
    end

    info(1, "Done")
    return
end

-- start by taking new snapshots of the subvolumes specified 
info(1, "########################################")
info(1, "Taking snapshots.....Timestamp:  "..timestamp)
for name, path in pairs(runtime.subvolumes) do
    local dest = string.format("%s/%s.%s", 
                               runtime.snapshot_dir, 
                               name,
                               timestamp)
    assert(btrfs_sv_snapshot(path, dest), btrbu_error)
end
info(1,"Snapshots completed")
info(1, "########################################")

-- Snapshots and backups have similar names- a name specified by the user and a
-- timestamp assigned by btrbu separated by a dot:  eg "name.timestamp" or more
-- specifically "name.YYYYMMDDhhmm"
-- create a table from the from the snapshot directory, splitting the name up 
-- between the name and timestamp.  We'll need that to help with pruning
snaps = buildTbl(runtime.snapshot_dir, timestamp)

-- run snaphooks now...
if runtime.snaphooks then
    print("SNAPHOOKS!")
    math.randomseed(os.time()+os.clock()*1000000)  -- random number generator is used in hook function
    for name, _ in pairs(runtime.subvolumes) do
        if runtime.snaphooks[name] then
            -- just make sure something is there
            if #runtime.snaphooks[name] ~= 0 then
                local r
                local s = runtime.snapshot_dir.."/"..name.."."..timestamp
                local hookcmd = runtime.snaphooks[name]:gsub("{snapshot}", s)
                hookcmd = hookcmd:gsub("{archive}", name)
                hookcmd = hookcmd:gsub("{timestamp}", timestamp)
                hookcmd = hookcmd:gsub("{snapshotdir}", runtime.snapshot_dir)
                table.insert(colist, { co = coroutine.create(hook), cmd = hookcmd })
                coroutine.resume(colist[#colist].co, hookcmd, #colist)
            end
        end        
    end
end

-- check if we're doing snapshots only
if runtime.snaps_only then
    -- yup, snaps only, so all done
    info(1, "Snapshots only specified")
    for name, _ in pairs(runtime.subvolumes) do
        local keeps = bldKeepList(snaps[name])
        showKeeps(name, keeps, nil, timestamp)
        applyKeepPolicy(snaps[name], keeps, name, runtime.snapshot_dir)
    end

    handleHooks()
    info(1,"Done")
    return
end

-- doing snapshots AND backups...
backups = buildTbl(runtime.backup_dir, timestamp)

-- snapshots are done, now for each snapshot determine if we should perform an incremental or full backup
-- after the backup is completed, prune the snapshots and the backups for this particular subvolume
for name, _ in pairs(runtime.subvolumes) do

    -- setup some path strings
    local snapshot_prefix = runtime.snapshot_dir.."/"..name.."."
    local source = snapshot_prefix..timestamp
    local dest = runtime.backup_dir

    -- get the parent for the current archive
    local snapkeeps = bldKeepList(snaps[name])
    local backupkeeps = nil
    local parent_ts = nil
    if backups[name] then 
        backupkeeps = bldKeepList(backups[name]) 
        if ( runtime.keep_daily + runtime.keep_monthly + runtime.keep_monthly ) == 0 then
            parent_ts = getParentfromCurrent(snaps[name], backups[name], timestamp)
        else
            parent_ts = getParentfromKeeps(snapkeeps, backupkeeps, timestamp)
        end
    end
    info(1, "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
    -- in no valid parent, then perform a full backup, otherwise perform an incremental backup
    -- getParent chooses the most recent timestamp for the incremental backup
    if not parent_ts then 
        info(1, "No valid parent found, doing full backup")
        assert(btrfs_send(nil, source, dest), btrbu_error)
    else
        local parent_path = snapshot_prefix..parent_ts
        info(1, "Doing incremental backup for subvolume: "..runtime.subvolumes[name])
        info(2, "Parent Timestamp: "..parent_ts)
        assert(btrfs_send(parent_path, source, dest), btrbu_error)
        info(1, "Done")
    end

    -- update the backup keep list now that we've added a backup
    backups = buildTbl(runtime.backup_dir, timestamp)
    backupkeeps = bldKeepList(backups[name])

    -- now prune the snapshot and backup directories
    showKeeps(name, snapkeeps, backupkeeps, timestamp)

    -- apply keep policy to snapshots
    applyKeepPolicy(snaps[name], snapkeeps, name, runtime.snapshot_dir)
    applyKeepPolicy(backups[name], backupkeeps, name, runtime.backup_dir)

    info(1, "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
end

info(1, "\nBackups completed.  Archive Timestamp: "..timestamp)
handleHooks()

