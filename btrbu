#!/usr/bin/env lua

-- system requires
local io = require("io")
local math = require("math")
local os = require("os")
local table = table -- for faster access

-- local requires
local MAX_INFO = 3

local usage = {
[[
Usage:  btrbu [OPTIONS] [archive1=/path/to/subvolume1] [archive2=/path/to/subvolume2] ...
]],
[[
btrbu is a program to create and manage snapshots and backups for btrfs subvolumes.  Minimally, it requires a snapshot destination path, a backup destination path, and a list of source volumes to take snapshots of and backup. These can all be supplied on the command line or in a config file.  Names for the snapshots and backups must be supplied- btrbu will append a timestamp to the name to create the snapshot/backup. 
]],
[[
If no archive/subvolume pairs are specified on the command line, btrbu will look for them in a config file.  The default config file is "~/.config/btrbu-conf" but the user can specify a particular file with the "--config" option.  If there are no archive/subvolume pairs specified in a config file, then there is nothing to do and the user gets this message.  Command line archive/subvolume pairs take precedence and prevent operations on archive/subvolume pairs specified in a config file.  NO ATTEMPT IS MADE TO RECONCILE BETWEEN THE COMMAND LINE AND CONFIG FILE FOR ARCHIVE/SUBVOLUME PAIRS, BEHAVIOR IS EITHER/OR.
]],
[[
All command line options can also be specified in a config file.  In the case where an option is defined both on the command line and in the config file, btrbu defaults to using the command line.
]],
[[
Options:
]],
}
local usage_length = #usage

-- table of valid options 
-- * table key is the option 
-- * value is another table with 
--   * "help_text" as one key and 
--   * "args" representing how many arguments the option takes.  
-- For now, only 1 or 0 arguments per option is supported
local btrbu_opts = {
    snapshot_dir = {
                     help_text = [[
Path to destination for snapshots
]],
                     args = 1,
    },
    backup_dir = {
                     help_text = [[
Path to location for backups.  For now, it is assumed that the destination is a btrfs based filesystem.
]],
    },
    config = {
                     help_text = [[
Path to a configuration file.  The configuration file contains a lua table with the desired option settings and archive/subvolume pairs.  See below for details and an example.
]],
                     args = 1,
    },
    snaps_only = {
                     help_text = [[
If specified only snapshots will be taken, no backups will be used.
]],
                     args = 0,
    },
    keep_daily = {
                     help_text = [[
Number of daily backups to be kept. Dailies kept have 24 hours between them.
]],
                     args = 1,
    },
    keep_weekly = {
                     help_text = [[
Number of weeklys backups to be kept. Weeklies kept have (7*24) hours between them.
]],
                     args = 1,
    },
    keep_monthly = {
                     help_text = [[
Number of monthly backups to be kept.  Monthlies kept have (4*7*24) hours between them.
]],
                     args = 1,
    },
    help = {
                     help_text = [[
Display this useful information.  The help option prevents execution of any operations, why would you be specifiying help, otherwise?
]],
                     args = 0,
    },
    verbose = {
                     help_text = [[
Option to turn on output about what is happening.  The default is no output, so if this is present the firehose is on.
]],
                     args = 1,
    },
    prune = {
                     help_text = [[
*** THIS REMOVES SNAPSHOTS AND BACKUPS- BE SURE THE RESULT IS KNOWN BY USING THE `dryrun` OPTION WITH THE DESIRED KEEP POLICY.  YOU HAVE BEEN WARNED. *** Applies keep policy without taking any snapshots or performing backups for the current run.  Can be used blank or a timestamp can be assigned.  The timestamp must be of the form `YYYYMMDDhhmm`.  If a timestamp is supplied then it applies the keep policy with the supplied timestamp used as the MOST RECENT entry.  Otherwise, a current timestamp is used.  When used with `dryrun`, useful for seeing the results of a keep policy on a large corpus of snapshots and backups.  Use of this option prevents any other actions, such as taking snapshots or performing backups, from occurring.
]],
                     args = "?",
    },
    dryrun = {
                     help_text = [[
No actual operations are performed.  Verbosity is set to max so the user can see what actions would be performed.  Because of how btrbu is implemented, the dryrun assumes all btrfs level actions will complete without error.
]],
                     args = 0,
    },
}

local btrbu_optcnt = 0
for k,_ in pairs(btrbu_opts) do btrbu_optcnt = btrbu_optcnt + 1 end

local configfilehelp = {
    [[
CONFIGURATION FILES
    ]],
    [[
At some point, if backing up several different subvolumes for instance, a configuration file might become desirable to make the command line more manageable.  btrbu will look for a configuration file in `~/.config/btrbu-conf` if no file is specified on the command line.  Alternatively:
    ]],
    [[
    btrbu --config=/path/to/myconfig
    ]],
    [[
Configuration files take advantage of lua's table syntax.  Don't worry, it's extremely easy to use.  A configuration file looks simply like so:
    ]],
    [[
    return { 
        subvolumes =  {
            archive1="/path/to/subvolume1",
            archive2="/path/to/subvolume2",
            archive3="/path/to/subvolume3",
        },
        -- the leading double-dash means a comment to lua, so that can be taken
        -- advantage of as well
        snapshot_dir = "/pool/snapshots",
        backup_dir = "/backup",
    }
    ]],
    [[
If an option can be specified on the command line, it can also be specified in the configuration file.  Be sure to susbstitute a `'_'` for any `'-'` characters in the command line option.  So the `--snapshot-dir` option would be specified as `snapshot_dir` in a configuration file.
    ]],
    [[
Configuration files and command line options can be mixed and matched as well.  The rule is that the command line overrides any configuration file settings.  For archive name/ subvolume pairs, anything specified on the command line overrides ALL of the subvolumes in the configuration file.  So if there are 5 subvolumes specified in the configuration file, but a single achive/subvolume is specified on the command line, only the command line archive/subvolume is dealt with.  Basically, btrbu assumes the user knows what they are doing and tries not to get in the way.
    ]]
}

local runtime = {}
runtime.subvolumes = {}
local options = {}

-- do some rudimentary command line parsing
--[[
    Options are denoted by a '--' prefix and are of the form "--option" or "--option=value"
    Archive/subvolume pairs are of the form "archive=subvolume"
    We try to remove remove white space if it is used when the command is invoked
    Also, order must be options followed by archive/subvolume pairs
--]]
local i = 1
local o = 1
while i <= #arg do
    local m = arg[i]:match("^%-%-(.+)")
    -- is this the start of an option argument? (leading '--')
    if o and m then
        options[o] = m
        i = i + 1
        if not arg[i] then break end;
        -- check if there's a trailing '='
        if m:match(".+=$") then
            -- yes, so grab next argument, stuff it and loop
            if not arg[i] then
                print("Argument parsing error at: "..options[o])
            end
            options[o] = options[o]..arg[i]
            i = i + 1
            o = o + 1
        -- does current match have a '='?
        elseif not m:find("=") then
            -- 2 possibilities- next arg could have the '=' or it can be 
            -- a new option
            -- chk for leading '='...
            if arg[i]:find("^=.*") then
                -- next arg has a leading '=', so it's either alone or already
                -- part of the value string
                if arg[i] == '=' then 
                    -- alone, so stuff it and then grab the next argument
                    options[o] = options[o]..'='
                    i = i + 1
                    -- make sure there is a next argument...
                    if not arg[i] then 
                        print("Argument parsing error at: "..options[o])
                        return
                    end
                end
                options[o] = options[o]..arg[i]
                i = i + 1
                o = o + 1
            -- chk for leading '--'...
            elseif arg[i]:find("^%-%-.*") then
                o = o + 1
            else
                -- next arg doesn't have '=' and isn't another option, so it
                -- must be the first archive/subvolume pair
                o = nil
            end
        else
            -- option match had an '=' in it, so stuff it and on to the next
            -- option
            o = o + 1
        end -- elseif not m:find...
    else
        -- not a leading '--' so we're looking for "archive=subvolume"
        -- variants, also- no more options allowed after this
        if m then
            print("Argument error- "..m)
            print("ALL options must precede archive/subvolume pairs.")
            return
        end
        
        if arg[i]:find("=") then
            m,v = arg[i]:match("^(.+)=(.+)$")
            if m then
                runtime.subvolumes[m] = v
                i = i + 1
            else
                m = arg[i]:match("^(.+)=$") 
                if m then
                    i = i + 1
                    if not arg[i] then
                        print("No subvolume specified for archive: "..m)
                        return
                    end
                    runtime.subvolumes[m] = arg[i]
                    i = i + 1
                else
                    print("No archive specified for subvolume: "..arg[i])
                    return
                end
            end
        else
            -- no '=' here, assume this is the archive name
            local archive = arg[i]
            i = i + 1
            if not arg[i] then
                print("No subvolume specified for archive: "..archive)
                return
            end

            -- now find the rest of the archive/subvolume pair
            if not arg[i]:find("=") then
                print("No subvolume specified for archive: "..archive)
                return
            end
            if arg[i] == "=" then
                -- just an '=' sign, so grab the next argument
                i = i + 1
                if not arg[i] then
                    print("No subvolume specified for archive: "..archive)
                    return
                end
                runtime.subvolumes[archive] = arg[i]
                i = i + 1
            else
                m = arg[i]:match("^=(.+)")
                if m then
                    runtime.subvolumes[archive] = m
                    i = i + 1
                else
                    print("Argument error: "..arg[i])
                    return
                end
            end    
        end
    end -- if o and m...
end -- while...

-- now setup runtime options
-- start with the options from the command line
if #options ~= 0 then
    for _,opt in ipairs(options) do
        -- must parse out option and value....
        if not opt:find("=") then
            -- just a switch
            local o = opt:gsub("-","_")
            if not btrbu_opts[o] then
                print("Invalid Option: "..opt)
                return
            elseif btrbu_opts[o].args ~= 0 and btrbu_opts[o].args ~= "?" then
                print("Option "..opt.." expects a value, none given.")
                return
            else
                runtime[o] = 1
            end
        else
            local k,v = opt:match("^([%w%-_]+)=(.+)$") 
            if not k then 
                print("Invalid Option: "..opt) 
                return
            end
            k = k:gsub("-","_")
            if not btrbu_opts[k] then
                print("Invalid Option: "..opt)
            elseif btrbu_opts[k].args == 0 then
                print("No value should be assigned to option: "..k:gsub("_","-"))
                return
            else
                runtime[k] = v
            end
        end
    end
end

 --[[ for debug...
print("User specified options:")
for _,v in ipairs(options) do print(v) end
print("Internal runtime options:")
for k,v in pairs(runtime) do
    print(k,v)
end
print("subvolumes:")
for k,v in pairs(runtime.subvolumes) do
    print(k,v)
end
 --]]

-- to keep this straight forward... if user specifies a config file
-- use that, if not, look for "~/.config/btrbu-conf
local cf = ""
if runtime.config then 
    local m = runtime.config:match("^~(.+)$")
    if m then
        cf = os.getenv("HOME")..m
    else
        cf = runtime.config
    end
else
    cf = os.getenv("HOME").."/.config/btrbu-conf"
end
-- try to load the config file
local settings, err = loadfile(cf)
-- now setup runtime config
-- if there is a conflict between command line and config file, use command line
-- if "archive=subvolume" specified on command line, only work with those 
-- supplied on command line.  DO NOT TRY TO RECONCILE COMMAND LINE WITH CONFIG
-- FILE FOR THIS.  IT'S ONE OR THE OTHER.
if settings then
    local cf_settings = settings()
    -- setup the subvolumes- subvolumes defined on command line override those
    -- in the config file; otherwise, add the entry
    if next(runtime.subvolumes) == nil then
        -- if table is empty, no command line settings for subvolumes, so just
        -- grab the whole table from config file
        runtime.subvolumes = cf_settings.subvolumes
    end
    -- go through and setup config file settings- if the option was already 
    -- setup on the command line, leave it
    if not runtime.snapshot_dir then
        runtime.snapshot_dir = cf_settings.snapshot_dir
    end
    if not runtime.backup_dir then
        runtime.backup_dir = cf_settings.backup_dir
    end

    if not runtime.keep_daily then
        runtime.keep_daily = cf_settings.keep_daily or 1
    end
    if not runtime.keep_weekly then 
        runtime.keep_weekly = cf_settings.keep_weekly or 0
    end
    if not runtime.keep_monthly then
        runtime.keep_monthly = cf_settings.keep_monthly or 0
    end
    if not runtime.snaps_only then
        runtime.snaps_only = cf_settings.snaps_only
    end
    if not runtime.verbose then
        runtime.verbose = tonumber(cf_settings.verbose) or 0
    else
        runtime.verbose = tonumber(runtime.verbose)
    end
    if not runtime.dryrun then
        runtime.dryrun = cf_settings.dryrun or nil
    end 
end

-- if we're doing a dryrun, set verbose to max 
if runtime.dryrun then runtime.verbose = MAX_INFO end

-- Sanity check- command line options and config file, if it exists, have been
-- processed.  In order to try to do anything, we need a snapshot destination,
-- and backup destination and some subvolumes to snapshot/backup.
-- ... OR ...
-- If the "--snaps_only" option is set then we need a snapshot destination and a
-- list of subvolumes to snapshot.
-- Also, the "--help" option is an override of sorts.  If that option was listed
-- on the command line, we display the usage text and exit.  Don't perform any
-- actions, even if we have enough to do so.
if ( not runtime.snapshot_dir or not runtime.backup_dir or next(runtime.subvolumes) == nil) or 
   ( runtime.snaps_only and 
     ( not runtime.snapshot_dir or next(runtime.subvolumes) == nil ) ) or runtime.help then
       -- DISPLAY USAGE TEXT AND EXIT
       -- we need to create a sorted table first...
       local sorted_opts = {}
       for k,_ in pairs(btrbu_opts) do table.insert(sorted_opts, k) end
       table.sort(sorted_opts)
       -- build the option text here prior to printing usage info
       for _, k in ipairs(sorted_opts) do
           local s = "  --"..k:gsub("_","-") -- map the '_' character to a
                                             -- '-' for the user to see and use
                                             -- when actually using the command
                                             -- line.  Internally, all '-' are
                                             -- mapped to '_' characters so the 
                                             -- tables work, since a '-' is not
                                             -- valid character for variables
                                             -- etc.
           table.insert(usage, s..string.rep(" ", 18-s:len())..btrbu_opts[k].help_text)
       end
       for _,v in ipairs(configfilehelp) do table.insert(usage, v) end
       -- get current terminal width
       local fd = io.popen("tput cols")
       local cols = fd:read("*a")
       fd:close()
       cols = tonumber(cols) - 1
       -- now go through the individual entries and fix them to the terminal width
       for i,v in ipairs(usage) do 
           local fixed_text = ""
           -- check for the 1 text block we don't want to reformat
           if not usage[i]:match("%sreturn %{") then 
               -- remove all linefeeds
               fixed_text = usage[i]:gsub("[\r\n]", " ")
               -- now format to the terminal width
               local length = fixed_text:len()
               if length > cols then
                   -- insert linefeeds as needed
                   local j = 1
                   local s = ""
                   repeat
                       local adjusted = cols
                       if (i > usage_length and i < (usage_length + btrbu_optcnt)) and s ~= "" then 
                           adjusted = adjusted - 18 
                       end
                       while fixed_text:sub(j+adjusted, j+adjusted) ~= " " do
                           adjusted = adjusted - 1
                       end
                       if j+adjusted+1 >= length then
                           s = s..fixed_text:sub(j, j+adjusted)
                       else
                           s = s..fixed_text:sub(j, j+adjusted).."\n"
                       end
                       if i > usage_length and i <= (usage_length + btrbu_optcnt) then 
                           s = s..string.rep(" ",18) 
                       end
                       j = j+adjusted+1
                   until j >= length
                   fixed_text = s
               end
               if i < usage_length or i >= (usage_length + btrbu_optcnt) then 
                   fixed_text = fixed_text.."\n" 
               end
           else -- if not usage(...
               fixed_text = usage[i]
           end
           print(fixed_text)
       end
   return -- exit program
end

-- ########################################
-- btrfs command functions

local function info(l, text)
    if runtime.verbose ~= 0 and runtime.verbose >= l then
        print(text)
    end
end

--[[

--]]
local function doit(cmd)
    info(2,cmd)
    local rs
    if not runtime.dryrun then
        fd = io.popen(cmd)
        rs = fd:read("*a")
        fd:close()
    else
        rs = "DRYRUN- no action performed"
    end
    info(3,rs)
    return rs
end

--[[

--]]
local function btrfs_sv_delete(sv)
    return doit("btrfs subvolume delete -c "..sv)
end

--[[

--]]
local function btrfs_sv_snapshot(s,d)
    return doit("btrfs subvolume snapshot -r "..s.." "..d)
end

--[[
    Ex:
    btrfs send -p cnkl77.2005052042/ cnkl77.2005152143/ | btrfs receive /backup/
--]]
local function btrfs_send(p,s,d)
    if not p then
        return doit("{ btrfs send "..s.." | btrfs receive "..d.." ; } 2>&1")
    else
        return doit("{ btrfs send -p "..p.." "..s.." | btrfs receive "..d.." ; } 2>&1")
    end
end

-- ########################################
--

local function tstoTime(ts)
    local t = {}
    t.year = ts:sub(1,4)
    t.month = ts:sub(5,6)
    t.day = ts:sub(7,8)
    t.hour = ts:sub(9,10)
    t.min = ts:sub(11,12)
    t.sec = 0
    return os.time(t)
end

-- Builds a table of archive names along with all the timestamps associated with those archives
-- Typically, this will be either a snapshot directory or a backup directory
local function buildTbl(path, current_ts)
    local fd = io.popen("find "..path.." -maxdepth 1 -print")
    local blob = fd:read("*a")
    fd:close()
    local t = {}
    for s in blob:gmatch("[^\r\n]+") do
        local name, ts = s:match(".*/(%g+)%.(%d%d%d%d%d%d%d%d%d%d%d%d)$")
        if name then
            if not t[name] then
                t[name] = {}
            end
            if ts < current_ts then table.insert(t[name], ts) end
        end
    end
    -- if doing a dryrun, then find won't return anything with the latest timestamp,
    -- so we need to insert it here 
    -- make sure the table timestamp tables are sorted
    for name, _ in pairs(t) do 
        if runtime.dryrun then table.insert(t[name], current_ts) end
        table.sort(t[name]) 
    end

    return t
end

--[[
    Returns the most recent timestamp that is common to both the snapkeeps and 
    backups keeps.  Note that backupkeeps will NOT have the current timestamp in it since we haven't
    tried to do a backup yet.  Btrfs needs a common archive to work with when generating incremental
    backups.
--]]
local function getParent(snapkeept, backupkeept, current_ts)
    
    local max = nil
    for k, _ in pairs(snapkeept) do
        -- if this snapshot timestamp is in the backup keep list, it's a candidate, otherwise move on
        if backupkeept[k] then
            if not max and k ~= current_ts then max = k
            elseif k < current_ts then max = tostring(math.max(max, k))
            end
        end
    end

    return max
end

--[[
    Function to determine what timestamps to keep.  This was a mess to figure
    out.  Only managed it because I built the algorithm for 1 case and then
    worked backwards to generalize it to work for 3 different intervals- daily,
    weekly and monthly

    Params:  tlist- table of timestamps to work through
             keep_tbl- destination table for timestamps to keep
             max_keeps- maximum number of keeps
             ts_start- seed timestamp when determining the slice
                       of timestamps from the tlist
             interval- a function that takes a timestamp as its first
                       parameter and a interval count for the second
--]]
local function getKeeps(timestamps, keep_tbl, max_keeps, ts_start, interval)
    -- scan backwards until through the list to find the starting timestamp
    local i = #timestamps
    while i ~= 0 and timestamps[i] > ts_start  do
       i = i - 1
    end
    if i == 0 then return nil end
    
    -- now start pulling timestamps
    local keep_cnt = 0
    local oldest_keep = nil
    repeat
        -- at this point, i is index to the most recent timestamp for the
        -- current interval so record it
        keep_tbl[timestamps[i]] = 1
        -- setup return value
        oldest_keep = timestamps[i]
        keep_cnt = keep_cnt + 1
        if keep_cnt == max_keeps then return oldest_keep end
        -- get next most recent timestamp for the current interval (days,weeks,
        -- months)
        local tsref = interval(timestamps[i], 1)
        i = i - 1
        -- this loop skips timestamps between the recorded one (in oldest_keep) 
        -- and the next next valid timestamp returned by the interval function
        while ( i ~= 0 and timestamps[i] > tsref ) do
            i = i - 1
        end
    until i == 0

    return oldest_keep
end

local function getKeepList(ts_list)
    -- these are some support functions that only getKeepList uses...
    --################################################################################
    -- returns a formatted timestamp for days_cnt days ago.
    -- The timestamp is set to the final minute of that day
    local function prevDay(ts, days_cnt)
        local t = os.date("*t", tstoTime(ts) - (days_cnt*24*3600))
        return string.format("%u%02u%02u%02u%02u",
                             t.year,
                             t.month,
                             t.day,
                             23,
                             59)
    end

    -- returns the most recent day of the previous week, initially, this is 
    -- always Saturday, but we can make that configurable...
    -- Sunday is day 1...Saturday is 7
    local function prevWeek(ts, week_cnt)
        local t = os.date("*t", tstoTime(ts))
        if t.wday ~= 7 then
            t = os.date("*t", os.time(t) - (24*3600)*(t.wday))
        end
        t = os.date("*t", os.time(t) - (week_cnt*(7*24*3600)))
        return string.format("%u%02u%02u%02u%02u",
                             t.year,
                             t.month,
                             t.day,
                             23,
                             59)
    end

    -- return last day of month that is months_cnt back
    -- it mimics the functionality of the prevWeek function, but works on months
    local function prevMonth(ts, months_cnt)
        local t = os.date("*t",tstoTime(ts))
        local chk_lastday = os.date("*t",os.time({ year = t.year,
                                                   month = t.month + 1,
                                                   day = 0 }))
        -- if months_cnt == 0 and the entry timestamp is the final day of the 
        -- month, nothing to do.  If entry timestamp is not the final day, return
        -- the final day of the previous month.  If months_cnt ~= 0 the return
        -- the final day of the month for months_cnt back.  For reference, using the
        -- lua libraries, month = month + 1 and day = 0 will return the last day of
        -- month
        if months_cnt ~= 0 then
            t = os.date("*t", os.time( { year = t.year,
                                         month = t.month-months_cnt+1,
                                         day = 0,
                                         hour = 23,
                                         min = 59 }
                                       )
                    )
        elseif t.day ~= chk_lastday.day then
            t = os.date("*t", os.time( { year = t.year,
                                         month = t.month,
                                         day = 0,
                                         hour = 23,
                                         min = 59 }
                                       )
                    )
        end

        return string.format("%u%02u%02u%02u%02u",
                             t.year,
                             t.month,
                             t.day,
                             t.hour,
                             t.min)
    end

    --################################################################################
    -- start of getKeepList code...
    local keeps = {}
    local oldest_keep = nil

    -- start with daily...
    -- always keep the most recent timestamp, which will be the last one
    if runtime.keep_daily ~= 0 then
        oldest_keep = getKeeps(ts_list,
                               keeps,
                               runtime.keep_daily,
                               ts_list[#ts_list],
                               prevDay
                              )
    end
    if runtime.keep_weekly ~= 0 then
        oldest_keep = getKeeps(ts_list,
                               keeps,
                               runtime.keep_weekly,
                               prevWeek(prevDay(oldest_keep or ts_list[#ts_list], 1), 0),
                               prevWeek
                              )
    end
    if runtime.keep_monthly ~= 0 then
        getKeeps(ts_list,
                 keeps,
                 runtime.keep_monthly,
                 prevMonth(prevDay(oldest_keep or ts_list[#ts_list], 1), 0),
                 prevMonth
                )
    end

    return keeps
end

-- Little helper function to consolidate some common processing
local function keepHelper(list, keeps, name, path)
    for _,v in ipairs(list) do
        if not keeps[v] then
            btrfs_sv_delete(path.."/"..name.."."..v)
        end
    end
end

-- fixup the snapshot_dir, backup_dir values and subvolume directories- convert
-- leading '~' and '.' to the appropriate value so we have a full path
-- specfication
local function pathFixup(path)
    local m = path:match("^~(.*)$") 
    if m then
        return os.getenv("HOME")..m
    end
    m = path:match("^%.(.*)$") 
    if m then
        return os.getenv("PWD")..m
    end
    -- nothing to do
    return path
end

runtime.snapshot_dir = pathFixup(runtime.snapshot_dir)
runtime.backup_dir = pathFixup(runtime.backup_dir)
for name, path in pairs(runtime.subvolumes) do
   runtime.subvolumes[name] = pathFixup(path)
end

-- assemble a timestamp to use as a suffix
local t = os.date("*t")
local timestamp = string.format("%u%02u%02u%02u%02u", 
                                t.year, 
                                t.month, 
                                t.day, 
                                t.hour, 
                                t.min)

-- if prune option is selected, perform it and exit
if runtime.prune then
    if runtime.prune ~= 1 then
        if runtime.prune:match("^%d%d%d%d%d%d%d%d%d%d%d%d$") then
            timestamp = runtime.prune
        else
            print("Invalid timestamp format for prune")
            print("Prune argument should be assigned a timestamp formatted as 'YYYYMMDDhhmm'")
            print("Aborting")
            return
        end
    end

    local snaps = buildTbl(runtime.snapshot_dir, timestamp)
    local backups = buildTbl(runtime.backup_dir, timestamp)

    for name, _ in pairs(runtime.subvolumes) do
        local snapkeeps = getKeepList(snaps[name])
        local backupkeeps = getKeepList(backups[name])

        info(1, "----------------------------------------")
        info(1, "Timestamp: "..timestamp)
        info(1, "Keep policy:")
        info(1, "\t"..runtime.keep_daily.." daily\n\t"..runtime.keep_weekly.." weekly\n\t"..runtime.keep_monthly.." monthly")
        -- apply keep policy to snapshots
        keepHelper(snaps[name], snapkeeps, name, runtime.snapshot_dir)
        keepHelper(backups[name], backupkeeps, name, runtime.backup_dir)

        -- show what we're keeping
        -- only do this if verbose is sufficiently high, otherwise just wasting time
        if runtime.verbose >= 1 then
            local function displayKeeps(whichkeep,keeplist,path,suffix)
                info(1, whichkeep)
                for k,_ in pairs(keeplist) do
                    info(1,"\t"..path.."/"..suffix.."."..k)
                end
            end
            displayKeeps("Keeping snapshots:", snapkeeps, runtime.snapshot_dir, name)
            displayKeeps("Keeping backups:", backupkeeps, runtime.backup_dir, name)
        end

        info(1, "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
        
    end

    info(1, "Done")
    return
end

-- start by taking new snapshots of the subvolumes specified 
info(1, "########################################")
info(1, "Taking snapshots.....Timestamp:  "..timestamp)
for name, path in pairs(runtime.subvolumes) do
    local dest = string.format("%s/%s.%s", 
                               runtime.snapshot_dir, 
                               name,
                               timestamp)
    btrfs_sv_snapshot(path, dest)
end
info(1,"Snapshots completed")
info(1, "########################################")

-- Snapshots and backups have similar names- a name specified by the user and a
-- timestamp assigned by btrbu separated by a dot:  eg "name.timestamp" or more
-- specifically "name.YYYYMMDDhhmm"
-- create a table from the from the snapshot directory, splitting the name up 
-- between the name and timestamp.  We'll need that to help with pruning
snaps = buildTbl(runtime.snapshot_dir, timestamp)

-- check if we're doing snapshots only
if runtime.snaps_only then
    -- yup, snaps only, so all done
    info(1, "Snapshots only specified")
    info(1, "----------------------------------------")
    info(1, "Keep Policy:")
    info(1, "\t"..runtime.keep_daily.." daily\n\t"..runtime.keep_weekly.." weekly\n\t"..runtime.keep_monthly.." monthly")
    for name, _ in pairs(runtime.subvolumes) do
        local keeps = getKeepList(snaps[name])
        keepHelper(snaps[name], keeps, name, runtime.snapshot_dir)

        if runtime.verbose >= 1 then
            for k,_ in pairs(keeps) do 
                info(2,"Keeping: "..runtime.snapshot_dir.."/"..name.."."..k) 
            end
        end
    end

    info(1,"Done")
    return
end

-- doing snapshots AND backups...
backups = buildTbl(runtime.backup_dir, timestamp)

-- now backup and prune our snapshots, and do our incremental backups
for name, _ in pairs(runtime.subvolumes) do

    -- setup some path strings
    local snapshot_prefix = runtime.snapshot_dir.."/"..name.."."
    local source = snapshot_prefix..timestamp
    local dest = runtime.backup_dir

    -- get the parent for the current archive
    local snapkeeps = getKeepList(snaps[name])
    local backupkeeps = nil
    local parent_ts = nil
    if backups[name] then 
        backupkeeps = getKeepList(backups[name]) 
        parent_ts = getParent(snapkeeps, backupkeeps, timestamp)
    end
    info(1, "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
    -- in no valid parent, then perform a full backup, otherwise perform an incremental backup
    -- getParent chooses the most recent timestamp for the incremental backup
    if not parent_ts then 
        info(1, "No valid parent found, doing full backup")
        btrfs_send(nil, source, dest)
    else
        local parent_path = snapshot_prefix..parent_ts
        info(1, "Doing incremental backup for subvolume: "..runtime.subvolumes[name])
        info(2, "Parent Timestamp: "..parent_ts)
        btrfs_send(parent_path, source, dest)
        info(1, "Done")
    end

    -- update the backup keep list now that we've added a backup
    backups = buildTbl(runtime.backup_dir, timestamp)
    backupkeeps = getKeepList(backups[name])

    -- now prune the snapshot and backup directories
    info(1, "----------------------------------------")
    info(1, "Timestamp: "..timestamp)
    info(1, "Keep policy:")
    info(1, "\t"..runtime.keep_daily.." daily\n\t"..runtime.keep_weekly.." weekly\n\t"..runtime.keep_monthly.." monthly")
    -- apply keep policy to snapshots
    keepHelper(snaps[name], snapkeeps, name, runtime.snapshot_dir)
    keepHelper(backups[name], backupkeeps, name, runtime.backup_dir)

    -- show what we're keeping
    -- only do this if verbose is sufficiently high, otherwise just wasting time
    if runtime.verbose >= 1 then
        local function displayKeeps(whichkeep,keeplist,path,suffix)
            info(1, whichkeep)
            for k,_ in pairs(keeplist) do
                info(1,"\t"..path.."/"..suffix.."."..k)
            end
        end
        displayKeeps("Keeping snapshots:", snapkeeps, runtime.snapshot_dir, name)
        displayKeeps("Keeping backups:", backupkeeps, runtime.backup_dir, name)
    end

    info(1, "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
end

info(1, "\nBackups completed.  Archive Timestamp: "..timestamp)

