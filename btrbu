#!/usr/bin/env lua

-- system requires
local io = require("io")
local math = require("math")
local os = require("os")
local table = table -- for faster access

-- local requires
local seconds_per_day = 86400
local seconds_per_week = 604800

usage = {
[[
Usage:  btrbu [OPTIONS] [archive1=/path/to/subvolume1] [archive2=/path/to/subvolume2] ...
]],
[[
btrbu is a program to create and manage snapshots and backups for btrfs subvolumes.  Minimally, it requires a snapshot destination path, a backup destination path, and a list of source volumes to take snapshots of and backup. These can all be supplied on the command line or in a config file.  Names for the snapshots and backups must be supplied- btrbu will append a timestamp to the name to create the snapshot/backup. 
]],
[[
If no archive/subvolume pairs are specified on the command line, btrbu will look for them in a config file.  The default config file is "~/.config/btrbu-conf" but the user can specify a particular file with the "--config" option.  If there are no archive/subvolume pairs specified in a config file, then there is nothing to do and the user gets this message.  Command line archive/subvolume pairs take precedence and prevent operations on archive/subvolume pairs specified in a config file.  NO ATTEMPT IS MADE TO RECONCILE BETWEEN THE COMMAND LINE AND CONFIG FILE FOR ARCHIVE/SUBVOLUME PAIRS, BEHAVIOR IS EITHER/OR.
]],
[[
All command line options can also be specified in a config file.  In the case where an option is defined both on the command line and in the config file, btrbu defaults to using the command line.
]],
[[
Options:
]],
}
usage_length = #usage

-- table of valid options 
-- * table key is the option 
-- * value is another table with 
--   * "help_text" as one key and 
--   * "args" representing how many arguments the option takes.  
-- For now, only 1 or 0 arguments per option is supported
local btrbu_opts = {
    snapshot_dir = {
                     help_text = [[
Path to destination for snapshots
]],
                     args = 1,
    },
    backup_dir = {
                     help_text = [[
Path to location for backups.  For now, it is assumed that the destination is a btrfs based filesystem.
]],
    },
    config = {
                     help_text = [[
Path to a configuration file.
]],
                     args = 1,
    },
    snaps_only = {
                     help_text = [[
If specified only snapshots will be taken, no backups will be used.
]],
                     args = 0,
    },
    keep_daily = {
                     help_text = [[
Number of daily backups to be kept. Dailies kept have 24 hours between them.
]],
                     args = 1,
    },
    keep_weekly = {
                     help_text = [[
Number of weeklys backups to be kept. Weeklies kept have (7*24) hours between them.
]],
                     args = 1,
    },
    keep_monthly = {
                     help_text = [[
Number of monthly backups to be kept.  Monthlies kept have (4*7*24) hours between them.
]],
                     args = 1,
    },
    help = {
                     help_text = [[
Display this useful information.  The help option prevents execution of any operations, why would you be specifiying help, otherwise?
]],
                     args = 0,
    },
    verbose = {
                     help_text = [[
Option to turn on output about what is happening.  The default is no output, so if this is present the firehose is on.
]],
                     args = 1,
    },
    prune = {
                     help_text = [[
Removes snapshots and backups according to the keep_daily, keep_weekly and keep_monthly options.    
]],
                     args = 1,
    },
}

local runtime = {}
runtime.subvolumes = {}
local options = {}

-- do some rudimentary command line parsing
--[[
    Options are denoted by a '--' prefix and are of the form "--option" or "--option=value"
    Archive/subvolume pairs are of the form "archive=subvolume"
    We try to remove remove white space if it is used when the command is invoked
    Also, order must be options followed by archive/subvolume pairs
--]]
local i = 1
local o = 1
while i <= #arg do
    local m = arg[i]:match("^%-%-(.+)")
    -- is this the start of an option argument? (leading '--')
    if o and m then
        options[o] = m
        i = i + 1
        if not arg[i] then break end;
        -- check if there's a trailing '='
        if m:match(".+=$") then
            -- yes, so grab next argument, stuff it and loop
            if not arg[i] then
                print("Argument parsing error at: "..options[o])
            end
            options[o] = options[o]..arg[i]
            i = i + 1
            o = o + 1
        -- does current match have a '='?
        elseif not m:find("=") then
            -- 2 possibilities- next arg could have the '=' or it can be 
            -- a new option
            -- chk for leading '='...
            if arg[i]:find("^=.*") then
                -- next arg has a leading '=', so it's either alone or already
                -- part of the value string
                if arg[i] == '=' then 
                    -- alone, so stuff it and then grab the next argument
                    options[o] = options[o]..'='
                    i = i + 1
                    -- make sure there is a next argument...
                    if not arg[i] then 
                        print("Argument parsing error at: "..options[o])
                        return
                    end
                end
                options[o] = options[o]..arg[i]
                i = i + 1
                o = o + 1
            -- chk for leading '--'...
            elseif arg[i]:find("^%-%-.*") then
                o = o + 1
            else
                -- next arg doesn't have '=' and isn't another option, so it
                -- must be the first archive/subvolume pair
                o = nil
            end
        else
            -- option match had an '=' in it, so stuff it and on to the next
            -- option
            o = o + 1
        end -- elseif not m:find...
    else
        -- not a leading '--' so we're looking for "archive=subvolume"
        -- variants, also- no more options allowed after this
        if m then
            print("Argument error- "..m)
            print("ALL options must precede archive/subvolume pairs.")
            return
        end
        
        if arg[i]:find("=") then
            m,v = arg[i]:match("^(.+)=(.+)$")
            if m then
                runtime.subvolumes[m] = v
                i = i + 1
            else
                m = arg[i]:match("^(.+)=$") 
                if m then
                    i = i + 1
                    if not arg[i] then
                        print("No subvolume specified for archive: "..m)
                        return
                    end
                    runtime.subvolumes[m] = arg[i]
                    i = i + 1
                else
                    print("No archive specified for subvolume: "..arg[i])
                    return
                end
            end
        else
            -- no '=' here, assume this is the archive name
            local archive = arg[i]
            i = i + 1
            if not arg[i] then
                print("No subvolume specified for archive: "..archive)
                return
            end

            -- now find the rest of the archive/subvolume pair
            if not arg[i]:find("=") then
                print("No subvolume specified for archive: "..archive)
                return
            end
            if arg[i] == "=" then
                -- just an '=' sign, so grab the next argument
                i = i + 1
                if not arg[i] then
                    print("No subvolume specified for archive: "..archive)
                    return
                end
                runtime.subvolumes[archive] = arg[i]
                i = i + 1
            else
                m = arg[i]:match("^=(.+)")
                if m then
                    runtime.subvolumes[archive] = m
                    i = i + 1
                else
                    print("Argument error: "..arg[i])
                    return
                end
            end    
        end
    end -- if o and m...
end -- while...

-- now setup runtime options
-- start with the options from the command line
if #options ~= 0 then
    for _,opt in ipairs(options) do
        -- must parse out option and value....
        if not opt:find("=") then
            -- just a switch
            local o = opt:gsub("-","_")
            if not btrbu_opts[o] then
                print("Invalid Option: "..opt)
                return
            elseif btrbu_opts[o].args ~= 0 then
                print("Option "..opt.." expects a value, none given.")
                return
            else
                runtime[o] = 1
            end
        else
            local k,v = opt:match("^([%w%-_]+)=(.+)$") 
            if not k then 
                print("Invalid Option: "..opt) 
                return
            end
            k = k:gsub("-","_")
            if not btrbu_opts[k] then
                print("Invalid Option: "..opt)
            elseif btrbu_opts[k].args == 0 then
                print("No value should be assigned to option: "..k:gsub("_","-"))
                return
            else
                runtime[k] = v
            end
        end
    end
end

 --[[ for debug...
print("User specified options:")
for _,v in ipairs(options) do print(v) end
print("Internal runtime options:")
for k,v in pairs(runtime) do
    print(k,v)
end
print("subvolumes:")
for k,v in pairs(runtime.subvolumes) do
    print(k,v)
end
 --]]

-- to keep this straight forward... if user specifies a config file
-- use that, if not, look for "~/.config/btrbu-conf
local cf = ""
if runtime.config then 
    local m = runtime.config:match("^~(.+)$")
    if m then
        cf = os.getenv("HOME")..m
    else
        cf = runtime.config
    end
else
    cf = os.getenv("HOME").."/.config/btrbu-conf"
end
-- try to load the config file
local settings, err = loadfile(cf)
-- now setup runtime config
-- if there is a conflict between command line and config file, use command line
-- if "archive=subvolume" specified on command line, only work with those 
-- supplied on command line.  DO NOT TRY TO RECONCILE COMMAND LINE WITH CONFIG
-- FILE FOR THIS.  IT'S ONE OR THE OTHER.
if settings then
    local cf_settings = settings()
    -- setup the subvolumes- subvolumes defined on command line override those
    -- in the config file; otherwise, add the entry
    if next(runtime.subvolumes) == nil then
        -- if table is empty, no command line settings for subvolumes, so just
        -- grab the whole table from config file
        runtime.subvolumes = cf_settings.subvolumes
    end
    -- go through and setup config file settings- if the option was already 
    -- setup on the command line, leave it
    if not runtime.snapshot_dir then
        runtime.snapshot_dir = cf_settings.snapshot_dir
    end
    if not runtime.backup_dir then
        runtime.backup_dir = cf_settings.backup_dir
    end

    if not runtime.keep_daily then
        runtime.keep_daily = cf_settings.keep_daily or 1
    end
    if not runtime.keep_weekly then 
        runtime.keep_weekly = cf_settings.keep_weekly or 0
    end
    if not runtime.keep_monthly then
        runtime.keep_monthly = cf_settings.keep_monthly or 0
    end
    if not runtime.snaps_only then
        runtime.snaps_only = cf_settings.snaps_only
    end
    if not runtime.verbose then
        runtime.verbose = tonumber(cf_settings.verbose) or 0
    else
        runtime.verbose = tonumber(runtime.verbose)
    end
end

-- Sanity check- command line options and config file, if it exists, have been
-- processed.  In order to try to do anything, we need a snapshot destination,
-- and backup destination and some subvolumes to snapshot/backup.
-- ... OR ...
-- If the "--snaps_only" option is set then we need a snapshot destination and a
-- list of subvolumes to snapshot.
-- Also, the "--help" option is an override of sorts.  If that option was listed
-- on the command line, we display the usage text and exit.  Don't perform any
-- actions, even if we have enough to do so.
if ( not runtime.snapshot_dir or 
     not runtime.backup_dir or 
     next(runtime.subvolumes) == nil) or 
   ( runtime.snaps_only and 
     ( not runtime.snapshot_dir or next(runtime.subvolumes) == nil ) ) or 
   runtime.help then
       -- DISPLAY USAGE TEXT AND EXIT
       -- we need to create a sorted table first...
       local sorted_opts = {}
       for k,_ in pairs(btrbu_opts) do table.insert(sorted_opts, k) end
       table.sort(sorted_opts)
       -- build the option text here prior to printing usage info
       for _, k in ipairs(sorted_opts) do
           local s = "  --"..k:gsub("_","-") -- map the '_' character to a
                                             -- '-' for the user to see and use
                                             -- when actually using the command
                                             -- line.  Internally, all '-' are
                                             -- mapped to '_' characters so the 
                                             -- tables work, since a '-' is not
                                             -- valid character for variables
                                             -- etc.
           table.insert(usage, 
                        s..string.rep(" ", 18-s:len())..btrbu_opts[k].help_text)
       end
       -- get current terminal width
       local fd = io.popen("tput cols")
       local cols = fd:read("*a")
       fd:close()
       cols = tonumber(cols) - 1
       -- now go through the individual entries and fix them to the terminal width
       for i,v in ipairs(usage) do 
           -- remove all linefeeds
           local fixed_text = usage[i]:gsub("[\r\n]", " ")
           -- now format to the terminal width
           local length = fixed_text:len()
           if length > cols then
               -- insert linefeeds as needed
               local j = 1
               local s = ""
               repeat
                   local adjusted = cols
                   if i > usage_length and s ~= "" then adjusted = adjusted - 18 end
                   while fixed_text:sub(j+adjusted, j+adjusted) ~= " " do
                       adjusted = adjusted - 1
                   end
                   if j+adjusted+1 >= length then
                       s = s..fixed_text:sub(j, j+adjusted)
                   else
                       s = s..fixed_text:sub(j, j+adjusted).."\n"
                   end
                   if i > usage_length then s = s..string.rep(" ",18) end
                   j = j+adjusted+1
               until j >= length
               fixed_text = s
           end
           if i < usage_length then fixed_text = fixed_text.."\n" end
           print(fixed_text)
       end
   return -- exit program
end

-- ########################################
-- btrfs command functions

local function info(l, text)
    if runtime.verbose ~= 0 and runtime.verbose >= l then
        print(text)
    end
end

--[[

--]]
local function doit(cmd)
    info(2,cmd)
    fd = io.popen(cmd)
    local rs = fd:read("*a")
    fd:close()
    info(3,rs)
    return rs
end

--[[

--]]
local function btrfs_sv_delete(sv)
    return doit("btrfs subvolume delete -c "..sv)
end

--[[

--]]
local function btrfs_sv_snapshot(s,d)
    return doit("btrfs subvolume snapshot -r "..s.." "..d)
end

--[[
    Ex:
    btrfs send -p cnkl77.2005052042/ cnkl77.2005152143/ | btrfs receive /backup/
--]]
local function btrfs_send(p,s,d)
    if not p then
        return doit("btrfs send "..s.." | btrfs receive "..d)
    else
        return doit("btrfs send -p "..p.." "..s.." | btrfs receive "..d)
    end
end

-- ########################################
--

local function tstoTime(ts)
    local t = {}
    t.year = ts:sub(1,4)
    t.month = ts:sub(5,6)
    t.day = ts:sub(7,8)
    t.hour = ts:sub(9,10)
    t.min = ts:sub(11,12)
    t.sec = 0
    return os.time(t)
end

-- Builds a table of archive names along with all the timestamps associated with those archives
-- Typically, this will be either a snapshot directory or a backup directory
local function buildTbl(path)
    local fd = io.popen("find "..path.." -maxdepth 1 -print")
    local blob = fd:read("*a")
    fd:close()
    local t = {}
    for s in blob:gmatch("[^\r\n]+") do
        local name, ts = s:match(".*/(%g+)%.(%d%d%d%d%d%d%d%d%d%d%d%d)$")
        if name then
            if not t[name] then
                t[name] = {}
            end
            table.insert(t[name], ts)
        end
    end
    -- make sure the table timestamp tables are sorted
    for name, _ in pairs(t) do table.sort(t[name]) end

    return t
end

--[[
    Returns the most recent timestamp that is common to both the snapkeeps and 
    backups keeps.  Note that backupkeeps will NOT have the current timestamp in it since we haven't
    tried to do a backup yet.  Btrfs needs a common archive to work with when generating incremental
    backups.
--]]
local function getParent(snapkeept, backupkeept, current_ts)
    
    local max = nil
    for k, _ in pairs(snapkeept) do
        -- if this snapshot timestamp is in the backup keep list, it's a candidate, otherwise move on
        if backupkeept[k] then
            if not max and k ~= current_ts then max = k
            elseif k < current_ts then max = tostring(math.max(max, k))
            end
        end
    end

    return max
end

--[[
    Function to determine what timestamps to keep.  This was a mess to figure
    out.  Only managed it because I built the algorithm for 1 case and then
    worked backwards to generalize it to work for 3 different intervals- daily,
    weekly and monthly

    Params:  tlist- table of timestamps to work through
             keep_tbl- destination table for timestamps to keep
             max_keeps- maximum number of keeps
             ts_start- seed timestamp when determining the slice
                       of timestamps from the tlist
             interval- a function that takes a timestamp as its first
                       parameter and a interval count for the second
--]]
local function getKeeps(timestamps, keep_tbl, max_keeps, ts_start, interval)
    -- scan backwards until through the list to find the starting timestamp
    local i = #timestamps
    while i ~= 0 and timestamps[i] > ts_start  do
       i = i - 1
    end
    if i == 0 then return nil end
    
    -- now start pulling timestamps
    local keep_cnt = 0
    local oldest_keep = nil
    repeat
        -- at this point, i is index to the most recent timestamp for the
        -- current interval so record it
        keep_tbl[timestamps[i]] = 1
        -- setup return value
        oldest_keep = timestamps[i]
        keep_cnt = keep_cnt + 1
        if keep_cnt == max_keeps then return oldest_keep end
        -- get next most recent timestamp for the current interval (days,weeks,
        -- months)
        local tsref = interval(timestamps[i], 1)
        i = i - 1
        -- this loop skips timestamps between the recorded one (in oldest_keep) 
        -- and the next next valid timestamp returned by the interval function
        while ( i ~= 0 and timestamps[i] > tsref ) do
            i = i - 1
        end
    until i == 0

    return oldest_keep
end

local function getKeepList(ts_list)
    -- these are some support functions that only getKeepList uses...
    --################################################################################
    -- returns a formatted timestamp for days_cnt days ago.
    -- The timestamp is set to the final minute of that day
    local function prevDay(ts, days_cnt)
        local t = os.date("*t", tstoTime(ts) - (days_cnt*24*3600))
        return string.format("%u%02u%02u%02u%02u",
                             t.year,
                             t.month,
                             t.day,
                             23,
                             59)
    end

    -- returns the most recent day of the previous week, initially, this is 
    -- always Saturday, but we can make that configurable...
    -- Sunday is day 1...Saturday is 7
    local function prevWeek(ts, week_cnt)
        local t = os.date("*t", tstoTime(ts))
        if t.wday ~= 7 then
            t = os.date("*t", os.time(t) - (24*3600)*(t.wday))
        end
        t = os.date("*t", os.time(t) - (week_cnt*(7*24*3600)))
        return string.format("%u%02u%02u%02u%02u",
                             t.year,
                             t.month,
                             t.day,
                             23,
                             59)
    end

    -- return last day of month that is months_cnt back
    -- it mimics the functionality of the prevWeek function, but works on months
    local function prevMonth(ts, months_cnt)
        local t = os.date("*t",tstoTime(ts))
        local chk_lastday = os.date("*t",os.time({ year = t.year,
                                                   month = t.month + 1,
                                                   day = 0 }))
        -- if months_cnt == 0 and the entry timestamp is the final day of the 
        -- month, nothing to do.  If entry timestamp is not the final day, return
        -- the final day of the previous month.  If months_cnt ~= 0 the return
        -- the final day of the month for months_cnt back.  For reference, using the
        -- lua libraries, month = month + 1 and day = 0 will return the last day of
        -- month
        if months_cnt ~= 0 then
            t = os.date("*t", os.time( { year = t.year,
                                         month = t.month-months_cnt+1,
                                         day = 0,
                                         hour = 23,
                                         min = 59 }
                                       )
                    )
        elseif t.day ~= chk_lastday.day then
            t = os.date("*t", os.time( { year = t.year,
                                         month = t.month,
                                         day = 0,
                                         hour = 23,
                                         min = 59 }
                                       )
                    )
        end

        return string.format("%u%02u%02u%02u%02u",
                             t.year,
                             t.month,
                             t.day,
                             t.hour,
                             t.min)
    end

    --################################################################################
    -- start of getKeepList code...
    local keeps = {}
    local oldest_keep = nil

    -- start with daily...
    -- always keep the most recent timestamp, which will be the last one
    if runtime.keep_daily ~= 0 then
        oldest_keep = getKeeps(ts_list,
                               keeps,
                               runtime.keep_daily,
                               ts_list[#ts_list],
                               prevDay
                              )
    end
    if runtime.keep_weekly ~= 0 then
        oldest_keep = getKeeps(ts_list,
                               keeps,
                               runtime.keep_weekly,
                               prevWeek(prevDay(oldest_keep or ts_list[#ts_list], 1), 0),
                               prevWeek
                              )
    end
    if runtime.keep_monthly ~= 0 then
        getKeeps(ts_list,
                 keeps,
                 runtime.keep_monthly,
                 prevMonth(prevDay(oldest_keep or ts_list[#ts_list], 1), 0),
                 prevMonth
                )
    end

    return keeps
end

-- fixup the snapshot_dir, backup_dir values and subvolume directories- convert
-- leading '~' and '.' to the appropriate value so we have a full path
-- specfication
local function pathFixup(path)
    local m = path:match("^~(.*)$") 
    if m then
        return os.getenv("HOME")..m
    end
    m = path:match("^%.(.*)$") 
    if m then
        return os.getenv("PWD")..m
    end
    -- nothing to do
    return path
end
runtime.snapshot_dir = pathFixup(runtime.snapshot_dir)
runtime.backup_dir = pathFixup(runtime.backup_dir)
for name, path in pairs(runtime.subvolumes) do
   runtime.subvolumes[name] = pathFixup(path)
end

-- assemble a timestamp to use as a suffix
local t = os.date("*t")
local timestamp = string.format("%u%02u%02u%02u%02u", 
                                t.year, 
                                t.month, 
                                t.day, 
                                t.hour, 
                                t.min)

-- start by taking new snapshots of the subvolumes specified 
info(1, "########################################")
info(1, "Taking snapshots.....Timestamp:  "..timestamp)
for name, path in pairs(runtime.subvolumes) do
    local dest = string.format("%s/%s.%s", 
                               runtime.snapshot_dir, 
                               name,
                               timestamp)
    btrfs_sv_snapshot(path, dest)
end
info(1,"Snapshots completed")
info(1, "########################################")

-- Snapshots and backups have similar names- a name specified by the user and a
-- timestamp assigned by btrbu separated by a dot:  eg "name.timestamp" or more
-- specifically "name.YYYYMMDDhhmm"
-- create a table from the from the snapshot directory, splitting the name up 
-- between the name and timestamp.  We'll need that to help with pruning
snaps = buildTbl(runtime.snapshot_dir)

-- check if we're doing snapshots only
if runtime.snaps_only then
    -- yup, snaps only, so all done
    info(1, "Snapshots only specified")
    info(1, "----------------------------------------")
    info(1, "Keep Policy:")
    info(1, "\t"..runtime.keep_daily.." daily\n\t"..runtime.keep_weekly.." weekly\n\t"..runtime.keep_monthly.." monthly")
    for name, _ in pairs(runtime.subvolumes) do
        local keeps = getKeepList(snaps[name])
        for _,v in ipairs(snaps[name]) do
            if not keeps[v] then 
                btrfs_sv_delete(runtime.snapshot_dir.."/"..name.."."..v)
            end
        end
        for k,_ in pairs(keeps) do 
            info(2,"Keeping: "..runtime.snapshot_dir.."/"..name.."."..k) 
        end
    end

    info(1,"Done")
    return
end

-- doing snapshots AND backups...
backups = buildTbl(runtime.backup_dir)

-- now backup and prune our snapshots, and do our incremental backups
for name, _ in pairs(runtime.subvolumes) do

    -- setup some path strings
    local snapshot_prefix = runtime.snapshot_dir.."/"..name.."."
    local source = snapshot_prefix..timestamp
    local dest = runtime.backup_dir

    -- get the parent for the current archive
    local snapkeeps = getKeepList(snaps[name])
    local backupkeeps = nil
    local parent_ts = nil
    if backups[name] then 
        backupkeeps = getKeepList(backups[name]) 
        parent_ts = getParent(snapkeeps, backupkeeps, timestamp)
    end
    info(1, "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
    -- in no valid parent, then perform a full backup, otherwise perform an incremental backup
    -- getParent chooses the most recent timestamp for the incremental backup
    if not parent_ts then 
        info(1, "No valid parent found, doing full backup")
        btrfs_send(nil, source, dest)
    else
        local parent_path = snapshot_prefix..parent_ts
        info(1, "Doing incremental backup for subvolume: "..runtime.subvolumes[name])
        info(2, "Parent Timestamp: "..parent_ts)
        btrfs_send(parent_path, source, dest)
        info(1, "Done")
    end

    -- update the backup keep list now that we've added a backup
    backups = buildTbl(runtime.backup_dir)
    backupkeeps = getKeepList(backups[name])

    -- now prune the snapshot and backup directories
    info(1, "----------------------------------------")
    info(1, "Keep policy:")
    info(1, "\t"..runtime.keep_daily.." daily\n\t"..runtime.keep_weekly.." weekly\n\t"..runtime.keep_monthly.." monthly")
    -- apply keep policy to snapshots
    local function keepHelper(list, keeps, path)
        for _,v in ipairs(list[name]) do
            if not keeps[v] then
                btrfs_sv_delete(path.."/"..name.."."..v)
            end
        end
    end
    keepHelper(snaps, snapkeeps, runtime.snapshot_dir)
    keepHelper(backups, backupkeeps, runtime.backup_dir)

    -- show what we're keeping
    -- only do this if verbose is sufficiently high, otherwise just wasting time
    if runtime.verbose > 1 then
        local function displayKeeps(whichkeep,keeplist,path,suffix)
            info(1, whichkeep)
            for k,_ in pairs(keeplist) do
                info(1,"\t"..path.."/"..suffix.."."..k)
            end
        end
        displayKeeps("Keeping snapshots:", snapkeeps, runtime.snapshot_dir, name)
        displayKeeps("Keeping backups:", backupkeeps, runtime.backup_dir, name)
    end

    info(1, "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
end

info(1, "\nBackups completed.  Archive Timestamp: "..timestamp)

